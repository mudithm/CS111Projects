Total: 745 samples
     557  74.8%  74.8%      745 100.0% listAdd_spin
     130  17.4%  92.2%      130  17.4% __strcmp_sse42
      32   4.3%  96.5%       98  13.2% SortedList_lookup
      21   2.8%  99.3%       90  12.1% SortedList_insert
       4   0.5%  99.9%        4   0.5% _init
       1   0.1% 100.0%        1   0.1% __GI__IO_fflush
       0   0.0% 100.0%      745 100.0% __clone
       0   0.0% 100.0%      745 100.0% start_thread
ROUTINE ====================== listAdd_spin in /u/cs/ugrad/mudith/Documents/CS111Projects/Lab2B/lab2_list.c
   557    745 Total samples (flat / cumulative)
     .      .  251:     }
     .      .  252: }
     .      .  253: 
     .      .  254: // Makes and deletes lists, with spin lock
     .      .  255: void listAdd_spin(int *offset)
---
     .      .  256: {
     .      .  257:     struct timespec spin_start, spin_end;
     .      .  258:     long long spin_start_time, spin_end_time;
     .      .  259: 
     .      .  260:     Sublist_t *list;
     .      .  261:     SortedList_t *head;
     .      .  262: 
     .      .  263:     for (int i = *offset; i < numIterations + *offset; i++)
     .      .  264:     {
     .      .  265:         list = &(sublist_array[hash(list_array[i].key) % numSublists]);
     .      .  266:         head = &(list->list_head);
     .      .  267: 
     .      .  268:         //printf("Adding #%d: %s to sublist #%ld\n", i, list_array[i].key, hash(list_array[i].key) % numSublists);
     .      .  269:         //fflush(stdout);
     .      .  270: 
     .      .  271:         //spin lock
     .      .  272:         clock_gettime(CLOCK_MONOTONIC, &spin_start);
     .      .  273:         spin_start_time = spin_start.tv_sec * 1000000000 + spin_start.tv_nsec;
     .      .  274: 
   370    370  275:         while (__sync_lock_test_and_set(&(list->spin_lock), 1))
     1      1  276:             continue;
     .      .  277: 
     .      .  278:         clock_gettime(CLOCK_MONOTONIC, &spin_end);
     .      .  279:         spin_end_time = spin_end.tv_sec * 1000000000 + spin_end.tv_nsec;
     1      1  280:         protected_wait_time += (spin_end_time - spin_start_time);
     .      .  281: 
     .      .  282: 
     .     90  283:         SortedList_insert(head, &list_array[i]);
     .      .  284:         //print2List(head);
     .      .  285: 
     .      .  286: 
     .      .  287: 
     .      .  288:         __sync_lock_release(&(list->spin_lock));
     .      .  289: 
     .      .  290:     }
     .      .  291: 
     .      .  292:     // check length of list
     .      .  293:     int len = 0;
     .      .  294: 
     .      .  295:     for (int i = 0; i < numSublists; i++)
     .      .  296:     {
     .      .  297:         list = &(sublist_array[i]);
     .      .  298:         head = &(list->list_head);
     .      .  299: 
     .      .  300:         clock_gettime(CLOCK_MONOTONIC, &spin_start);
     .      .  301:         spin_start_time = spin_start.tv_sec * 1000000000 + spin_start.tv_nsec;
     .      .  302: 
     .      .  303:         while (__sync_lock_test_and_set(&(list->spin_lock), 1))
     .      .  304:             continue;
     .      .  305: 
     .      .  306:         clock_gettime(CLOCK_MONOTONIC, &spin_end);
     .      .  307:         spin_end_time = spin_end.tv_sec * 1000000000 + spin_end.tv_nsec;
     .      .  308:         protected_wait_time += (spin_end_time - spin_start_time);
     .      .  309: 
     .      .  310:         int temp_len = SortedList_length(head);
     .      .  311: 
     .      .  312:         __sync_lock_release(&(list->spin_lock));
     .      .  313: 
     .      .  314:         if (temp_len < 0)
     .      .  315:         {
     .      .  316:             fprintf(stderr, "Corrupted list!\n");
     .      .  317:             exit(2);
     .      .  318:         }
     .      .  319: 
     .      .  320:         len += temp_len;
     .      .  321:     }
     .      .  322: 
     .      .  323: 
     .      .  324: 
     .      .  325:     //delete all added elements
     .      .  326: 
     .      .  327:     for (int i = *offset; i < numIterations + *offset; i++)
     .      .  328:     {
     .      .  329:         //printf("removing #%d: %s\n", i, list_array[i].key);
     .      .  330:         //fflush(stdout);
     .      .  331:         //mutex lock
     .      .  332:         //printf("%s is waiting on mutex lock:  -----------------------\n", list_array[i].key);
     .      .  333:         //fflush(stdout);
     .      .  334: 
     .      .  335:         list = &(sublist_array[hash(list_array[i].key) % numSublists]);
     .      .  336:         head = &(list->list_head);
     .      .  337: 
     .      .  338:         clock_gettime(CLOCK_MONOTONIC, &spin_start);
     .      .  339:         spin_start_time = spin_start.tv_sec * 1000000000 + spin_start.tv_nsec;
   184    184  340:         while (__sync_lock_test_and_set(&(list->spin_lock), 1))
     .      .  341:             continue;
     .      .  342:         clock_gettime(CLOCK_MONOTONIC, &spin_end);
     .      .  343:         spin_end_time = spin_end.tv_sec * 1000000000 + spin_end.tv_nsec;
     1      1  344:         protected_wait_time += (spin_end_time - spin_start_time);
     .      .  345: 
     .      .  346:         //printf("%s received lock.         -----------------------\n", list_array[i].key);
     .      .  347:         // print2List(&(list.list_head));
     .      .  348: 
     .     98  349:         if (SortedList_delete(SortedList_lookup(head, list_array[i].key)))
     .      .  350:         {
     .      .  351:             fprintf(stderr, "Error deleting element %s!\n", list_array[i].key);
     .      .  352:             exit(2);
     .      .  353:         }
     .      .  354:         __sync_lock_release(&(list->spin_lock));
     .      .  355: 
     .      .  356: 
     .      .  357:     }
     .      .  358: 
     .      .  359: 
     .      .  360: 
     .      .  361: 
     .      .  362: }
---
     .      .  363: 
     .      .  364: int main(int argc, char *argv[])
     .      .  365: {
     .      .  366: 
     .      .  367:     const struct option opts[] =
ROUTINE ====================== listAdd_spin in /u/cs/ugrad/mudith/Documents/CS111Projects/Lab2B/lab2_list.c
   557    745 Total samples (flat / cumulative)
     .      .  251:     }
     .      .  252: }
     .      .  253: 
     .      .  254: // Makes and deletes lists, with spin lock
     .      .  255: void listAdd_spin(int *offset)
---
     .      .  256: {
     .      .  257:     struct timespec spin_start, spin_end;
     .      .  258:     long long spin_start_time, spin_end_time;
     .      .  259: 
     .      .  260:     Sublist_t *list;
     .      .  261:     SortedList_t *head;
     .      .  262: 
     .      .  263:     for (int i = *offset; i < numIterations + *offset; i++)
     .      .  264:     {
     .      .  265:         list = &(sublist_array[hash(list_array[i].key) % numSublists]);
     .      .  266:         head = &(list->list_head);
     .      .  267: 
     .      .  268:         //printf("Adding #%d: %s to sublist #%ld\n", i, list_array[i].key, hash(list_array[i].key) % numSublists);
     .      .  269:         //fflush(stdout);
     .      .  270: 
     .      .  271:         //spin lock
     .      .  272:         clock_gettime(CLOCK_MONOTONIC, &spin_start);
     .      .  273:         spin_start_time = spin_start.tv_sec * 1000000000 + spin_start.tv_nsec;
     .      .  274: 
   370    370  275:         while (__sync_lock_test_and_set(&(list->spin_lock), 1))
     1      1  276:             continue;
     .      .  277: 
     .      .  278:         clock_gettime(CLOCK_MONOTONIC, &spin_end);
     .      .  279:         spin_end_time = spin_end.tv_sec * 1000000000 + spin_end.tv_nsec;
     1      1  280:         protected_wait_time += (spin_end_time - spin_start_time);
     .      .  281: 
     .      .  282: 
     .     90  283:         SortedList_insert(head, &list_array[i]);
     .      .  284:         //print2List(head);
     .      .  285: 
     .      .  286: 
     .      .  287: 
     .      .  288:         __sync_lock_release(&(list->spin_lock));
     .      .  289: 
     .      .  290:     }
     .      .  291: 
     .      .  292:     // check length of list
     .      .  293:     int len = 0;
     .      .  294: 
     .      .  295:     for (int i = 0; i < numSublists; i++)
     .      .  296:     {
     .      .  297:         list = &(sublist_array[i]);
     .      .  298:         head = &(list->list_head);
     .      .  299: 
     .      .  300:         clock_gettime(CLOCK_MONOTONIC, &spin_start);
     .      .  301:         spin_start_time = spin_start.tv_sec * 1000000000 + spin_start.tv_nsec;
     .      .  302: 
     .      .  303:         while (__sync_lock_test_and_set(&(list->spin_lock), 1))
     .      .  304:             continue;
     .      .  305: 
     .      .  306:         clock_gettime(CLOCK_MONOTONIC, &spin_end);
     .      .  307:         spin_end_time = spin_end.tv_sec * 1000000000 + spin_end.tv_nsec;
     .      .  308:         protected_wait_time += (spin_end_time - spin_start_time);
     .      .  309: 
     .      .  310:         int temp_len = SortedList_length(head);
     .      .  311: 
     .      .  312:         __sync_lock_release(&(list->spin_lock));
     .      .  313: 
     .      .  314:         if (temp_len < 0)
     .      .  315:         {
     .      .  316:             fprintf(stderr, "Corrupted list!\n");
     .      .  317:             exit(2);
     .      .  318:         }
     .      .  319: 
     .      .  320:         len += temp_len;
     .      .  321:     }
     .      .  322: 
     .      .  323: 
     .      .  324: 
     .      .  325:     //delete all added elements
     .      .  326: 
     .      .  327:     for (int i = *offset; i < numIterations + *offset; i++)
     .      .  328:     {
     .      .  329:         //printf("removing #%d: %s\n", i, list_array[i].key);
     .      .  330:         //fflush(stdout);
     .      .  331:         //mutex lock
     .      .  332:         //printf("%s is waiting on mutex lock:  -----------------------\n", list_array[i].key);
     .      .  333:         //fflush(stdout);
     .      .  334: 
     .      .  335:         list = &(sublist_array[hash(list_array[i].key) % numSublists]);
     .      .  336:         head = &(list->list_head);
     .      .  337: 
     .      .  338:         clock_gettime(CLOCK_MONOTONIC, &spin_start);
     .      .  339:         spin_start_time = spin_start.tv_sec * 1000000000 + spin_start.tv_nsec;
   184    184  340:         while (__sync_lock_test_and_set(&(list->spin_lock), 1))
     .      .  341:             continue;
     .      .  342:         clock_gettime(CLOCK_MONOTONIC, &spin_end);
     .      .  343:         spin_end_time = spin_end.tv_sec * 1000000000 + spin_end.tv_nsec;
     1      1  344:         protected_wait_time += (spin_end_time - spin_start_time);
     .      .  345: 
     .      .  346:         //printf("%s received lock.         -----------------------\n", list_array[i].key);
     .      .  347:         // print2List(&(list.list_head));
     .      .  348: 
     .     98  349:         if (SortedList_delete(SortedList_lookup(head, list_array[i].key)))
     .      .  350:         {
     .      .  351:             fprintf(stderr, "Error deleting element %s!\n", list_array[i].key);
     .      .  352:             exit(2);
     .      .  353:         }
     .      .  354:         __sync_lock_release(&(list->spin_lock));
     .      .  355: 
     .      .  356: 
     .      .  357:     }
     .      .  358: 
     .      .  359: 
     .      .  360: 
     .      .  361: 
     .      .  362: }
---
     .      .  363: 
     .      .  364: int main(int argc, char *argv[])
     .      .  365: {
     .      .  366: 
     .      .  367:     const struct option opts[] =
